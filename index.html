<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>From Rails to Ember: File uploads by decasia</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
      <div id="header">
        <nav>
          <li class="fork"><a href="https://github.com/decasia">View On GitHub</a></li>
        </nav>
      </div><!-- end header -->

    <div class="wrapper">

      <section>
        <div id="title">
          <h1>From Rails to Ember: File uploads</h1>
          <p></p>
          <hr>
          <span class="credits left">Project maintained by <a href="https://github.com/decasia">decasia</a></span>
          <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></span>
        </div>

        <h3>
<a name="preface" class="anchor" href="#preface"><span class="octicon octicon-link"></span></a>Preface</h3>

<p>I've recently started testing Ember on an internal web application we're building. Our apps were previously in more vanilla Ruby on Rails, but complicated HTML forms were sometimes slow to render, and as I found myself writing large amounts of jQuery to partially load content through ad hoc AJAX, things started to look ugly and maintainable, and it became increasingly obvious that a more rigorous client-side framework was the way to go. At RailsConf this year I heard Yehuda Katz criticize the view that Javascript is just something you "sprinkle" on your Rails app, without much of a theory of how Javascript should be structured -- I'm trying to take that to heart.</p>

<p>But when you move to something like Ember, a lot of features that used to be easy suddenly become hard. Here I want to document some of the new techniques and workarounds we've used to rebuild some of this lost functionality. To start out, let's talk about file uploads. (Note that all Ember code here is in CoffeeScript, with templates in <a href="http://emblemjs.com/">Emblem.js</a>; the Rails templates are Haml.)</p>

<h3>
<a name="file-uploads-in-rails" class="anchor" href="#file-uploads-in-rails"><span class="octicon octicon-link"></span></a>File uploads in Rails</h3>

<p>We use <a href="http://rubygems.org/gems/paperclip">Paperclip</a> for file uploads. It's great. If you have a model called (say) <code>report</code> with an associated model called <code>attachment</code>, and install Paperclip on the <code>attachment</code> model, everything becomes easy. </p>

<p>For upload:</p>

<p><code>= file_field_tag "attachment"</code></p>

<p>or for a download link:</p>

<pre><code>link_to [@report, attachment] do
  = attachment.electronic_document_file_name
</code></pre>

<p>The attachment controller doesn't have to do much more than this:</p>

<pre><code>def show
  attachment = Attachment.find params[:id]
  send_file attachment.electronic_document.path, type: attachment.electronic_document_content_type
end
</code></pre>

<h3>
<a name="ember-downloads" class="anchor" href="#ember-downloads"><span class="octicon octicon-link"></span></a>Ember downloads</h3>

<p>The downloads are still very easy in Ember. You can still use the same route on your Rails attachments controller to handle sending the uploaded files. You just have to build an Ember model to represent your attachment, something like this:</p>

<pre><code>App.Attachment = DS.Model.extend
  report: DS.belongsTo 'App.Report'
  notes: DS.attr 'string'
  createdAt: DS.attr 'date'
  updatedAt: DS.attr 'date'
  electronicDocumentFileName: DS.attr 'string'
  electronicDocumentFileSize: DS.attr 'number'
</code></pre>

<p>And then you may want to build an Ember controller (remembering that Ember controllers are really just like presenter objects) that adds some computed property to generate a download path for each attachment:</p>

<pre><code>App.AttachmentController = Ember.ObjectController.extend
  downloadPath: (-&gt;
    fileName = @get 'electronicDocumentFileName'
    if fileName &amp;&amp; fileName.length
      id = @get 'id'
      App.RailsRootPath + "/download/#{id}"
    else
      null
  ).property()
</code></pre>

<p>(In our case, we deploy our apps at different paths depending on the environment, so I define App.RailsRootPath in an Ember initializer.)</p>

<p>Once you've set this up, it's easy to create file download links anywhere in the app. Something like:</p>

<pre><code>a href=attachment.downloadPath
  = attachment.electronicDocumentFileName
</code></pre>

<p>If you set up a download route in your Rails routes that points to <code>attachments#show</code>, things will work perfectly.</p>

<p>Unfortunately, downloads are slightly less straightforward. I'll cover them in a moment.</p>
      </section>

    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>