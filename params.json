{"name":"From Rails to Ember: File uploads","tagline":"","body":"### Preface \r\n\r\nI've recently started testing Ember on an internal web application we're building. Our apps were previously in more vanilla Ruby on Rails, but complicated HTML forms were sometimes slow to render, and as I found myself writing large amounts of jQuery to partially load content through ad hoc AJAX, things started to look ugly and maintainable, and it became increasingly obvious that a more rigorous client-side framework was the way to go. At RailsConf this year I heard Yehuda Katz criticize the view that Javascript is just something you \"sprinkle\" on your Rails app, without much of a theory of how Javascript should be structured -- I'm trying to take that to heart.\r\n\r\nBut when you move to something like Ember, a lot of features that used to be easy suddenly become hard. Here I want to document some of the new techniques and workarounds we've used to rebuild some of this lost functionality. To start out, let's talk about file uploads. (Note that all Ember code here is in CoffeeScript, with templates in [Emblem.js](http://emblemjs.com/); the Rails templates are Haml.)\r\n\r\n### File uploads in Rails\r\n\r\nWe use [Paperclip](http://rubygems.org/gems/paperclip) for file uploads. It's great. If you have a model called (say) `report` with an associated model called `attachment`, and install Paperclip on the `attachment` model, everything becomes easy. \r\n\r\nFor upload:\r\n\r\n`= file_field_tag \"attachment\"`\r\n\r\nor for a download link:\r\n``` \r\nlink_to [@report, attachment] do\r\n  = attachment.electronic_document_file_name\r\n```\r\n\r\nThe attachment controller doesn't have to do much more than this:\r\n```\r\ndef show\r\n  attachment = Attachment.find params[:id]\r\n  send_file attachment.electronic_document.path, type: attachment.electronic_document_content_type\r\nend\r\n```\r\n\r\n### Ember downloads\r\nThe downloads are still very easy in Ember. You can still use the same route on your Rails attachments controller to handle sending the uploaded files. You just have to build an Ember model to represent your attachment, something like this:\r\n\r\n```\r\nApp.Attachment = DS.Model.extend\r\n  report: DS.belongsTo 'App.Report'\r\n  notes: DS.attr 'string'\r\n  createdAt: DS.attr 'date'\r\n  updatedAt: DS.attr 'date'\r\n  electronicDocumentFileName: DS.attr 'string'\r\n  electronicDocumentFileSize: DS.attr 'number'\r\n```\r\n\r\nAnd then you may want to build an Ember controller (remembering that Ember controllers are really just like presenter objects) that adds some computed property to generate a download path for each attachment:\r\n\r\n```\r\nApp.AttachmentController = Ember.ObjectController.extend\r\n  downloadPath: (->\r\n    fileName = @get 'electronicDocumentFileName'\r\n    if fileName && fileName.length\r\n      id = @get 'id'\r\n      App.RailsRootPath + \"/download/#{id}\"\r\n    else\r\n      null\r\n  ).property()\r\n```\r\n\r\n(In our case, we deploy our apps at different paths depending on the environment, so I define App.RailsRootPath in an Ember initializer.)\r\n\r\nOnce you've set this up, it's easy to create file download links anywhere in the app. Something like:\r\n\r\n```\r\na href=attachment.downloadPath\r\n  = attachment.electronicDocumentFileName\r\n```\r\n\r\nIf you set up a download route in your Rails routes that points to `attachments#show`, things will work perfectly.\r\n\r\nUnfortunately, downloads are slightly less straightforward. I'll cover them in a moment.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}